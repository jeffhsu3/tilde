#! /usr/bin/python
"""
sample_pairs

This script takes a table of SNP pairs generated by indv_test and randomly
selects one pair within a window of some size. Then it sums the log
likelihood of every randomly selected pair and stores the result.

Based on Carlos's "select_pairs" script.

Sam Vohr (svohr@soe.ucsc.edu)

Fri Aug 15 13:26:38 PDT 2014
"""

import optparse
import sys
import random


def sample_log_prob( lines ):
    """ A random line from from a window (they can be repeated)
    and reads its log likelihood """
    if len(lines) > 0:
        samp_line = random.sample( lines, 1 )[0] 
        items = samp_line.rstrip().split()
        log_like = float(items[11])
        return log_like
    return 0.0


def process_positions( pos_in, win_size, skip_size ):
    """ Divides all the position in windows and runs sample_log_prob """
    probs = list()
    win_start, win_end = None, None
    win_chrom = None
    win_plus_skip_size = win_size + skip_size
    win_lines = None
    # instead of starting at 0 for each chromosome, we will pick an offset
    # so we do not exclude any lines for falling in between windows.
    chrom_offset = None

    for line in pos_in:
        items = line.rstrip().split()
        chrom = items[0]
        pos = int(items[1])

        # Check to see if we're in the same window 
        if win_chrom is None or win_chrom != chrom:
            if win_chrom is not None:
                # sample from the previous window
                probs.append(sample_log_prob(win_lines))
                del win_lines
            # Make a new window
            win_lines = list()
            win_chrom = chrom
            chrom_offset = random.randint(0, win_size-1)
            win_start = ((pos / win_plus_skip_size) 
                         * win_plus_skip_size) + chrom_offset
            win_end = win_start + win_plus_skip_size + chrom_offset
        elif pos >= win_end:
            # sample from the previous window
            probs.append(sample_log_prob(win_lines))

            # Same chromosome, move the window up.
            del win_lines
            win_lines = list()
            win_start = ((pos / win_plus_skip_size) 
                         * win_plus_skip_size) + chrom_offset
            win_end = win_start + win_plus_skip_size + chrom_offset
        if pos - win_start < win_size:
            # Only include lines within the window_size
            # leaving the skip size at the end of the 'super' window.
            if pos < win_start - skip_size:
                # Weird case here: it is possible that our current 
                # position is outside of our last window but not 
                # in the current window when we consider the offset.
                # If it falls before the start of the window but outside
                # of the skip distance, we will treat it as a singleton window
                # and save the value.
                probs.append(sample_log_prob([line]))
            else:
                win_lines.append(line)
    if win_lines is not None:
        probs.append(sample_log_prob(win_lines))
    # return the sum of the log likelihood ratios and the number of
    # positive observations and negative observations.
    return sum(probs), sum(p > 0 for p in probs), sum(p < 0 for p in probs)


def main(argv=None):
    ''' Repeatedly samples entries from sliding windows and sums the 
        log-likelihood ratios. '''
    if argv is None:
        argv = sys.argv
    usage = 'sample_pairs <filename>'
    parser = optparse.OptionParser(usage=usage)
    parser.add_option("-w", "--window", default=1000000, \
            action="store", type="int", dest="win_size", \
            help="The size of the window.")
    parser.add_option("-s", "--skip", default=100000, \
            action="store", type="int", dest="skip_size", \
            help="Bases to skip between windows")
    parser.add_option("-t", "--times", default=100, \
            action="store", type="int", dest="times", \
            help="How many resamplings to do.")
    (opts, args) = parser.parse_args()

    if len(args) < 1:
        parser.print_help()
        return -1
    
    for i in xrange(opts.times):
        with open(args[0], 'r') as pos_in:
            log_like, n_pos, n_neg = process_positions(pos_in, opts.win_size, 
                                                       opts.skip_size)
            print '%f\t%d\t%d' % (log_like, n_pos, n_neg)
    return 0


if __name__ == "__main__":
    sys.exit(main())
