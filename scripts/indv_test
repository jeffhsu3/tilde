#! /usr/bin/python
"""

This script takes a table of SNP pairs generated by 'pairs_in_range' and
the phased genotypes from VCFTools in impute format and calculates the 
the log conditional probabilities of observing the second base given the
observation of the first under two models, one where the reads come from
the same individual the other where the two reads come from separate 
individuals. These will be used to calculate an odds ratio to compare the
two models. This is described in more detail in the document for describing
this analysis.

Note: The way this script calculates the log-likelhood ratio for a pair of
SNP observations is different than described in the paper. The two models
compared here are written as conditional probabilities where the probability
of one observation is conditioned on the other. In the paper, the method
is described as calculating a joint probability of the two observations.
However, the log-likelihood ratios caculated by both methods are the same
since in the joint probability calculation, one of the allele frequencies
can be cancelled out when the ratio is calculated.

Sam Vohr (svohr@soe.ucsc.edu)
Thu Apr 24 10:33:03 PDT 2014

"""


import sys
import argparse
import math
import random

from scipy import stats


def read_impute_haps(hap_in, leg_in):
    """ Builds a two tables for the haplotype and legend impute files. """
    legend = dict()
    haps = dict()
    # bite off the header
    leg_in.readline() 
    for line in leg_in:
        items = line.split()
        pos, ref, alt = items[1], items[2], items[3]
        legend[pos] = [ref, alt]
        # Not really haplotype, genotypes for positions
        hap = ''.join(hap_in.readline().rstrip().split())
        haps[pos] = hap
    return haps, legend
    

def frac_allele(hap, allele):
    """ Returns count of the allele and the total number of haplotypes in the 
        population. """
    return hap.count(allele), len(hap)
    

def freq_allele(hap, allele):
    """ Returns the frequency of the allele in the population. """
    return hap.count(allele) / float(len(hap))


def calc_ld_d(hap_a, hap_b):
    """ Calculates LD measurement D for the two sites """
    frq_a = freq_allele(hap_a, '1')
    frq_b = freq_allele(hap_b, '1')
    ab_count = 0
    for i in range(len(hap_a)):
        if hap_a[i] == '1' and hap_b[i] == '1':
            ab_count += 1
    frq_ab = float(ab_count) / len(hap_a)
    return frq_ab - (frq_a * frq_b)


def calc_ld_r_squared(hap_a, hap_b):
    """ Calculates LD measurement r^2 for the two sites """
    ld_d = calc_ld_d(hap_a, hap_b)
    frq_a1 = freq_allele(hap_a, '1')
    frq_b1 = freq_allele(hap_b, '1')
    return (ld_d ** 2) / (frq_a1 * frq_b1 * (1 - frq_a1) * (1 - frq_b1))


def calc_ld_chi_squared(ld_r_squared, hap_a):
    """ Calulates the chi^2 value from r^2 and the number of chomosomes """
    return ld_r_squared * len(hap_a)


def calc_ld_chi_sq_p_val(ld_chi_squared):
    """ Calulates the chi^2 value from r^2 and the number of chomosomes """
    return 1 - stats.chi2.cdf(ld_chi_squared, 1)


def freq_b_given_a(hap_a, hap_b, allele_a, allele_b):
    """ Returns the conditional frequency of allele b, given allele a """
    a_count = 0
    ab_count = 0
    for i in xrange(len(hap_a)):
        if hap_a[i] == allele_a:
            a_count += 1
            if hap_b[i] == allele_b:
                ab_count += 1
    return ab_count / float(a_count)


def prob_b_given_a_one_indv(hap_a, hap_b, allele_a, allele_b):
    """ Returns the probability of making this observation in one indv. """
    return (0.5 * freq_b_given_a(hap_a, hap_b, allele_a, allele_b) + 
            0.5 * freq_allele(hap_b, allele_b))


def prob_b_given_a_two_indv(hap_a, hap_b, allele_a, allele_b):
    """ Returns the probability of making this observation in two indv. """
    return freq_allele(hap_b, allele_b)


def base_to_allele(legend, pos, base):
    """ Converts a nucleotide base to a 0 or 1 based on the reference and
        alternate alleles. Returns -1 if the base is not found in the 
        legend table. """
    if legend[pos] is None:
        return '-1'
    alleles = legend[pos]
    for i in range(len(alleles)):
        if alleles[i] == base:
            return str(i)
    sys.stderr.write("At %s: base %s not found in legend\n" % (pos, base))
    return '-1'


def choose_allele_by_freq(genotypes):
    """ Pick a random allele from the sample (i.e. dependent on freq.) """
    return random.choice(genotypes)


def choose_allele_by_coinflip():
    """ Pick a random allele by coin flip (0 or 1 equally likely) """
    return random.choice("01")


def choose_allele_by_coinflip_freq(hap_a, hap_b, allele_a, allele_b, haploid):
    """ Pick a random allele by coin flip deciding if the two observations
        are linked on the same chromosome. """
    genotypes = list(hap_b)
    # First, flip to see if these two observations are in phase 
    # (on the same chromosome)
    if random.choice([True, False]) or haploid:
        # Yes, same chromosome. Pick a random base using the frequency
        # conditioned on seeing allele A
        # delete all genotypes for b where the corresponding allele in 
        # hap_a does not match allele a
        for i in xrange(len(hap_b) - 1, -1, -1):
            if hap_a[i] != allele_a:
                del genotypes[i]
    # else: # No, pick a random base based on the overall allele frequencies.
    return choose_allele_by_freq(genotypes)


def calc_probs_for_base(haps, pos_a, allele_a, pos_b, allele_b, haploid):
    """ Calculates the probabilies that these observations came from
        1 individual or two individuals given our reference panel. """
    if allele_a == '-1' or allele_b == '-1':
        return None, None
    prob_one_indv = None
    if haploid:
        prob_one_indv = freq_b_given_a(haps[pos_a], haps[pos_b], 
                                       allele_a, allele_b) 
    else:
        prob_one_indv = prob_b_given_a_one_indv(haps[pos_a], haps[pos_b], 
                                                allele_a, allele_b) 
    prob_two_indv = prob_b_given_a_two_indv(haps[pos_a], haps[pos_b], 
                                            allele_a, allele_b) 
    return prob_one_indv, prob_two_indv 


def process_pair(haps, legend, pair_entry, haploid, rand_model, r_sq):
    """ Processes a single pair of SNPs, returning the probabilities of this
        observation under the two models. """
    pos_a = pair_entry[1]
    pos_b = pair_entry[2]
    base_a = pair_entry[5]
    base_b = pair_entry[8]
    
    allele_a = base_to_allele(legend, pos_a, base_a)
    allele_b = base_to_allele(legend, pos_b, base_b)
    
    if allele_a == '-1' or allele_b == '-1':
        return None, None, None
    
    pair_ld = None
    if r_sq:
        ld_r_squared = calc_ld_r_squared(haps[pos_a], haps[pos_b])
        pair_ld = (ld_r_squared, calc_ld_chi_squared(ld_r_squared, haps[pos_a]))
    else:
        pair_ld = calc_ld_d(haps[pos_a], haps[pos_b])
    
    # If we're using a random model and not the observed base
    if rand_model == '1':
        allele_b = choose_allele_by_coinflip_freq(haps[pos_a], haps[pos_b], 
                                                  allele_a, allele_b, haploid)
    elif rand_model == '2':
        allele_b = choose_allele_by_freq(haps[pos_b])

    # calculate probabilities for this pair of observed bases.
    prob_one_indv, prob_two_indv = calc_probs_for_base(haps,
                                                       pos_a, allele_a,
                                                       pos_b, allele_b,
                                                       haploid)
    return prob_one_indv, prob_two_indv, pair_ld


def process_pair_file(haps, legend, pair_in, args, pair_out):
    """ Processes all sets of pairs and writes output """
    total_log_ratio = 0
    use_chi_sq = args.chi_sq or (args.p_val is not None)
    for line in pair_in:
        pair_entry = line.rstrip().split()
        prob_one_indv, prob_two_indv, pair_ld = process_pair(haps, legend,
                                                             pair_entry,
                                                             args.haploid, 
                                                             args.random,
                                                             use_chi_sq)
        if prob_one_indv is None:
            continue # bad base, skip it
        log_prob_one_indv = math.log(prob_one_indv, 2)
        log_prob_two_indv = math.log(prob_two_indv, 2)
        log_odds_ratio = log_prob_one_indv - log_prob_two_indv
        pair_ld_pval = None
        if args.chi_sq or args.p_val:
            pair_ld_pval = calc_ld_chi_sq_p_val(pair_ld[1])
            pair_ld_str = '%f\t%f\t%f' % (pair_ld[0], pair_ld[1], pair_ld_pval)
        else:
            pair_ld_str = str(pair_ld)
        pair_entry = pair_entry + [str(prob_one_indv), str(prob_two_indv),
                                   str(log_odds_ratio), pair_ld_str]
        if args.p_val is None:
            pair_out.write('%s\n' % ('\t'.join(pair_entry)))
        elif pair_ld_pval is not None and pair_ld_pval < args.p_val:
            pair_out.write('%s\n' % ('\t'.join(pair_entry)))
        # else: p_value is set but calculated p_value does not pass.
        total_log_ratio += log_odds_ratio 
    return total_log_ratio


def main(argv=None):
    """ Calculates the probability and log-odds ratio for pairs of SNPs. """
    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser("Tests if two libraries are consistent "
                                     "with originating from 1 or 2 "
                                     "individuals based on a reference panel "
                                     "used to model the variation in the "
                                     "population to which they belong.")
    parser.add_argument('impute_hap', metavar='impute.hap', type=str, 
                        help='impute.hap file')
    parser.add_argument('impute_leg', metavar='impute.legend', type=str, 
                        help='impute.legend file')
    parser.add_argument('pairs_filename', metavar='pairs.tab', type=str,
                        nargs='?', default=None,
                        help='Table of SNP pairs')
    parser.add_argument('-x', '--haploid', action='store_true', 
                        help='Haploid mode (for chrX) NOT TESTED')
    parser.add_argument('-r', '--random', type=str, metavar='MODEL', 
                        default=None,
                        help='Randomly choose the second base using '
                             'model 1 (first base offers information '
                             'half the time) or model 2 (random weighted by '
                             'allele frequencies).')
    parser.add_argument('-X', '--chi-sq', action='store_true', 
                        help='Report LD as r^2 and include chi^2 and p value.')
    parser.add_argument('-p', '--p-val', type=float, metavar='P', 
                        default=None,
                        help='If set, test for LD using r^2 and do not report '
                             'pairs that do not reach this significance level '
                             '(implies -X).')
    args = parser.parse_args()

    hap_in = open(args.impute_hap, 'r')
    leg_in = open(args.impute_leg, 'r')
    haps, legend = read_impute_haps(hap_in, leg_in)
    hap_in.close()
    leg_in.close()

    pair_in = sys.stdin
    if args.pairs_filename is not None:
        pair_in = open(args.pairs_filename, 'r')

    total_log_ratio = process_pair_file(haps, legend, pair_in, 
                                        args, sys.stdout)
    pair_in.close()

    sys.stderr.write('%f\n' % (total_log_ratio))

    return 0


if __name__ == "__main__":
    sys.exit(main())
